<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé≠ Double Vision</title>
    <style>
        body {
            margin: 0;
        }
        .center-divider {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0.1vw;
            height: 100%;
            background-color: black;
        }
        .menu-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .menu-content {
            text-align: center;
            color: white;
            font-family: Arial, sans-serif;
        }
        .menu-button {
            padding: 10px 20px;
            font-size: 18px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .menu-button:hover {
            background-color: #45a049;
        }
        .toolbox {
            position: absolute;
            top: 10px;
            left: 10px; /* D√©placer vers le c√¥t√© gauche */
            width: 200px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 14px;
            border-radius: 5px;
            padding: 10px;
            z-index: 1000;
        }
        .toolbox h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            text-align: center;
        }
        .toolbox ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .toolbox ul li {
            margin-bottom: 5px;
        }
        .audio-svg {
            width: 10%;
            fill: url(#gradient); /* Appliquer le d√©grad√© au trac√© du SVG */
        }
        .volume-control {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: Arial, sans-serif;
            font-size: 14px;
            z-index: 1000;
            display: none; /* Masquer par d√©faut */
            flex-direction: column;
            align-items: center;
        }
        .volume-control input[type="range"] {
            -webkit-appearance: none;
            width: 100px;
            height: 8px;
            margin-top: 10px;
            border-radius: 5px; /* Arrondir le slider */
            background: #ccc;
            outline: none;
        }
        .volume-control input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 15px;
            height: 15px;
            border-radius: 50%; /* Arrondir le curseur */
            background: #4CAF50;
            cursor: pointer;
        }
        .volume-control img {
            width: 30px;
            height: 30px;
        }
    </style>
</head>
<body>
    <div class="menu-overlay" id="menuOverlay">
        <div class="menu-content">
            <h1>Bienvenue dans Double Vision</h1>
            <br>
            <img src="./Images/landscape.png" style="max-width: 10%;"> 
            <p>Veuiller passer en mode <strong>paysage</strong> de mani√®re aprofiter pleinement de cette experience</p>
            <p>Appuyez sur <strong>t</strong> pour afficher le guide des touches.</p>
            <br>
            <button class="menu-button" id="startButton">Commencer</button>
        </div>
    </div>
    <div class="toolbox">
        <h3>GUIDE DES TOUCHES</h3>
        <ul>
            <li><strong>i</strong> : Met en √©vidence les √©l√©ments modifiables</li>
            <li><strong>u</strong> : Afficher les √©l√©ments modifi√©s en jaune</li>
            <li><strong>clic</strong> : Trouver un √©l√©ment modifi√©</li>
            <li><strong>r</strong> : R√©initialiser la position des cam√©ras</li>
            <li><strong>t</strong> : Afficher ou masquer ce guide</li>
            <li><strong>espace</strong> : Mettre en pause ou reprendre la musique</li>
        </ul>
    </div>
    <div class="center-divider"></div>
    <div class="volume-control">
        <img src="./Images/Speaker_Icon.svg" alt="Speaker Icon">
        <input id="volumeSlider" type="range" min="0" max="1" step="0.01" value="0.5">
    </div>
    <audio id="backgroundMusic" src="/Musique/lofi-chill-315216.mp3" loop></audio>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';        
        const scene = new THREE.Scene();
        let SCREEN_WIDTH = window.innerWidth;
        let SCREEN_HEIGHT = window.innerHeight;
        scene.background = new THREE.Color(0x80CEFF); // Couleur du ciel
        const ratioLargeurHauteur = SCREEN_WIDTH / SCREEN_HEIGHT;

        const camera = new THREE.PerspectiveCamera(30, ratioLargeurHauteur, 0.1, 200); // Distance d'affichage
        camera.position.set(0, 5, 10); // Ajuster la position pour voir la sc√®ne
        camera.lookAt(0, 0, 0); // Orientation de la cam√©ra

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 2;
        controls.maxDistance = 5;
        controls.maxPolarAngle = Math.PI / 2;
        controls.dampingFactor = 0.05;

        const clock = new THREE.Clock();
        const mixers = [];

        const loaderGLTF = new GLTFLoader();

        const modifiableElements = ["bag", "lamp", "chair", "book1", "book2", "book3", "book4", "mouse", "console", "frame1", "frame2", "frame3", "frame4", "slipers", "table", "keyboard","cup"]; // Liste des √©l√©ments modifiables

        const sunLight = new THREE.DirectionalLight(0xffdd88, 1.5); // Lumi√®re chaude pour simuler le soleil
        sunLight.position.set(10, 20, 10); // Position √©lev√©e pour simuler le soleil
        sunLight.castShadow = true; // Activer les ombres
        sunLight.shadow.mapSize.width = 1024; // Taille de la carte d'ombre
        sunLight.shadow.mapSize.height = 1024;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 50;
        scene.add(sunLight);
        //Ajout com
        // Abaisser la premi√®re sc√®ne
        scene.position.y -= 0.5;

        // Configuration de la deuxi√®me sc√®ne
        const scene2 = new THREE.Scene();
        scene2.background = new THREE.Color(0x80CEFF); // M√™me couleur de fond que la premi√®re sc√®ne

        const camera2 = new THREE.PerspectiveCamera(30, SCREEN_WIDTH / SCREEN_HEIGHT, 0.1, 200);
        camera2.position.set(0, 5, 10); // Ajuster la position pour voir la sc√®ne
        camera2.lookAt(0, 0, 0);

        const controls2 = new OrbitControls(camera2, renderer.domElement);
        controls2.minDistance = 2;
        controls2.maxDistance = 5;
        controls2.maxPolarAngle = Math.PI / 2;
        controls2.dampingFactor = 0.05;

        // Cloner la lumi√®re pour la deuxi√®me sc√®ne
        const sunLight2 = sunLight.clone();
        scene2.add(sunLight2);

        // Abaisser la deuxi√®me sc√®ne
        scene2.position.y -= 0.5;

        const models = []; // Tableau pour stocker les mod√®les de la premi√®re sc√®ne
        const models2 = []; // Tableau pour stocker les mod√®les de la deuxi√®me sc√®ne
        const separatedObjects = []; // Tableau pour stocker les objets s√©par√©s

        function loadModel(path, scene, models, separatedObjects, selectable = false) {
            loaderGLTF.load(
                path,
                function (gltf) {
                    const mesh = gltf.scene;
                    const s = 0.35;
                    mesh.scale.set(s, s, s);
                    mesh.position.set(0, 0, 0); // Centrer le mod√®le dans la sc√®ne
                    mesh.rotation.x = 0; // Mettre droit

                    // Ajouter le mod√®le √† la sc√®ne
                    scene.add(mesh);
                    models.push(mesh); // Stocker le mod√®le dans le tableau

                    // Parcourir les enfants du mod√®le et attribuer le statut s√©lectionnable
                    mesh.traverse((child) => {
                        if (child.isMesh) {
                            child.userData.selectable = selectable; // Attribuer le statut s√©lectionnable
                            if (selectable) {
                                separatedObjects.push(child); // Ajouter uniquement les objets s√©lectionnables
                                console.log(`Objet s√©lectionnable ajout√© (${path}) :`, child.name);
                            } else {
                                console.log(`Objet non s√©lectionnable charg√© (${path}) :`, child.name);
                            }
                        }
                    });
                },
                undefined,
                function (err) {
                    console.error(`Erreur lors du chargement du mod√®le (${path}) :`, err);
                }
            );
        }

        // Charger les mod√®les dans les deux sc√®nes
        loadModel('./Models/isometric_bedroom/scene.gltf', scene, models, separatedObjects, false); // Non s√©lectionnable
        loadModel('./Models/isometric_bedroom/scene.gltf', scene2, models2, separatedObjects, false); // Non s√©lectionnable
        loadModel('./Models/isometric_bedroom/textures/models/bag.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/bag.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/cup.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/cup.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/mouse.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/mouse.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/console.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/console.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/book1.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/book1.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/slipers.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/slipers.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/lamp.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/lamp.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/book2.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/book2.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/book3.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/book3.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/chair.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/chair.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/book4.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/book4.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/table.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/table.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/keyboard.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/keyboard.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/frame1.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/frame1.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/frame2.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/frame2.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/frame3.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/frame3.gltf', scene2, models2, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/frame4.gltf', scene, models, separatedObjects, true);
        loadModel('./Models/isometric_bedroom/textures/models/frame4.gltf', scene2, models2, separatedObjects, true);

        // Raycaster pour d√©tecter les objets
        const raycaster = new THREE.Raycaster(); 
        // Position de la souris
        const mouse = new THREE.Vector2(); 
        // Dernier objet intersect√©
        let previousIntersected = null; 

        function onMouseMove(event) {
            // Calculer la position de la souris en coordonn√©es normalis√©es (-1 √† +1)
            mouse.x = ((event.clientX - SCREEN_WIDTH / 2) / (SCREEN_WIDTH / 2)) * 2 - 1; // Ajuster pour la sc√®ne 2
            mouse.y = -(event.clientY / SCREEN_HEIGHT) * 2 + 1;
        }

        function highlightObjectsScene2() {
            raycaster.setFromCamera(mouse, camera2);

            // Intersecter les objets dans la sc√®ne 2
            const intersects = raycaster.intersectObjects(models2, true).filter(intersect => 
                intersect.object.isMesh && intersect.object.userData.selectable === true && intersect.object.name !== 'scene.gltf' // Exclure scene.gltf
            );

            if (previousIntersected && previousIntersected !== intersects[0]?.object) {
                // R√©initialiser la couleur de l'objet pr√©c√©demment intersect√©
                if (previousIntersected.material && previousIntersected.userData.originalColor) {
                    previousIntersected.material.color.set(previousIntersected.userData.originalColor);
                }
                previousIntersected = null;
            }

            if (intersects.length > 0) {
                const intersected = intersects[0].object;

                // Mettre en surbrillance l'objet intersect√©
                if (intersected.isMesh && intersected.material) {
                    if (!intersected.userData.originalColor) {
                        intersected.userData.originalColor = intersected.material.color.clone();
                    }
                    intersected.material.color.set(0x0000ff); // Appliquer une surbrillance bleue
                    previousIntersected = intersected;
                }
            }
        }

        // Gestion des √©l√©ments modifi√©s et trouv√©s
        const modifiedElements = new Set(); // √âl√©ments modifi√©s par applyRandomizationToScene2
        const foundElements = new Set(); // √âl√©ments trouv√©s

        function addModifiedElement(element) {
            modifiedElements.add(element);
        }

        function isModifiedElement(element) {
            return modifiedElements.has(element);
        }

        function addFoundElement(element) {
            foundElements.add(element);
        }

        function isFoundElement(element) {
            return foundElements.has(element);
        }

        function resetElements() {
            modifiedElements.clear();
            foundElements.clear();
        }

        // Gestion du score
        const counterElement = document.createElement('div');
        counterElement.style.position = 'absolute';
        counterElement.style.top = '10px';
        counterElement.style.right = '10px';
        counterElement.style.padding = '10px';
        counterElement.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
        counterElement.style.color = 'white';
        counterElement.style.fontSize = '16px';
        counterElement.style.borderRadius = '5px';
        document.body.appendChild(counterElement);

        function updateCounter() {
            counterElement.innerText = `√âl√©ments trouv√©s : ${foundElements.size}/${modifiedElements.size}`;
            if (foundElements.size === modifiedElements.size && modifiedElements.size > 0) {
                showEndScreen(); // Afficher l'√©cran de fin
            }
        }

        // √âcran de fin
        const endScreen = document.createElement('div');
        endScreen.style.position = 'fixed';
        endScreen.style.top = '0';
        endScreen.style.left = '0';
        endScreen.style.width = '100%';
        endScreen.style.height = '100%';
        endScreen.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        endScreen.style.color = 'white';
        endScreen.style.display = 'flex';
        endScreen.style.flexDirection = 'column';
        endScreen.style.justifyContent = 'center';
        endScreen.style.alignItems = 'center';
        endScreen.style.zIndex = '1000';
        endScreen.style.display = 'none';
        endScreen.innerHTML = `
            <h1>Game Over</h1>
            <button id="replayButton" style="padding: 10px 20px; font-size: 18px; background-color: #4CAF50; color: white; border: none; border-radius: 5px; cursor: pointer;">Rejouer</button>
        `;
        document.body.appendChild(endScreen);

        function showEndScreen() {
            endScreen.style.display = 'flex'; // Afficher l'√©cran de fin
        }

        document.getElementById('replayButton').addEventListener('click', () => {
            endScreen.style.display = 'none'; // Masquer l'√©cran de fin
            resetElements(); // R√©initialiser les √©l√©ments modifi√©s et trouv√©s

            // R√©initialiser les couleurs des objets dans la sc√®ne
            scene2.traverse((child) => {
                if (child.isMesh && child.material && child.userData.selectable) {
                    child.material.color.set(child.userData.originalColor || 0xffffff); // R√©initialiser la couleur
                }
            });

            // R√©initialiser les cam√©ras et les contr√¥les
            camera.position.set(0, 5, 10);
            camera.lookAt(0, 0, 0);
            camera.updateProjectionMatrix();
            controls.reset();

            camera2.position.set(0, 5, 10);
            camera2.lookAt(0, 0, 0);
            camera2.updateProjectionMatrix();
            controls2.reset();

            // Appliquer une nouvelle randomisation √† la sc√®ne
            applyRandomizationToScene2(scene2, excludedModels);

            // R√©initialiser le compteur apr√®s la randomisation
            updateCounter();

            lives = 3; // R√©initialiser les vies
            updateLivesDisplay(); // Mettre √† jour l'affichage des vies
        });

        // Gestion des clics sur les √©l√©ments modifi√©s
        const excludedModels = ['scene.gltf']; // Exclure `scene.gltf` des interactions

        function onElementClick(event) {
            // Convertir la position de la souris en coordonn√©es normalis√©es (-1 √† +1)
            mouse.x = ((event.clientX - SCREEN_WIDTH / 2) / (SCREEN_WIDTH / 2)) * 2 - 1;
            mouse.y = -(event.clientY / SCREEN_HEIGHT) * 2 + 1;

            // Configurer le raycaster √† partir de camera2 et de la position de la souris
            raycaster.setFromCamera(mouse, camera2);

            // Intersecter les objets dans la sc√®ne 2
            const intersects = raycaster.intersectObjects(models2, true).filter(intersect => 
                intersect.object.isMesh && intersect.object.userData.selectable === true && !excludedModels.includes(intersect.object.name)
            );

            if (intersects.length > 0) {
                const clickedObject = intersects[0].object;

                // V√©rifier si l'objet cliqu√© est modifi√© et non encore trouv√©
                if (isModifiedElement(clickedObject) && !isFoundElement(clickedObject)) {
                    addFoundElement(clickedObject); // Marquer l'√©l√©ment comme trouv√©
                    updateCounter(); // Mettre √† jour le compteur de score
                } else if (!isModifiedElement(clickedObject)) {
                    loseLife(); // Perdre une vie si l'objet cliqu√© est s√©lectionnable mais non modifi√©
                }
            } else {
                console.log("Aucun objet d√©tect√© sous le clic.");
            }
        }

        window.addEventListener('click', onElementClick);

        // Section d√©di√©e aux fonctions de randomisation

        // Fonction pour appliquer une couleur al√©atoire (sans noir et blanc)
        function randomColor(mesh) {
            const randomColor = new THREE.Color(Math.random(), Math.random(), Math.random());
            if (randomColor.r !== randomColor.g || randomColor.g !== randomColor.b) { // Exclure noir et blanc
                mesh.material.color = randomColor;
            } else {
                randomColor(mesh); // R√©essayer si la couleur est noir ou blanc
            }
        }
       
        // Fonction pour g√©n√©rer une couleur al√©atoire unique qui n'est ni une nuance de noir ni une nuance de blanc
        function generateUniqueColor(existingColors) {
            let color;
            do {
                color = new THREE.Color(Math.random(), Math.random(), Math.random());
            } while (
                (color.r === color.g && color.g === color.b) || // Exclure les nuances de gris (y compris noir et blanc)
                existingColors.some(
                    (existingColor) =>
                        existingColor.r === color.r &&
                        existingColor.g === color.g &&
                        existingColor.b === color.b
                )
            );
            return color;
        }

         // Fonction pour g√©n√©rer un nombre al√©atoire entre 5 et 10 inclus
        function getRandomNumberBetween5And10() {
            return Math.floor(Math.random() * (10 - 7 + 1)) + 5;
        }
        /**
         * Fonction pour obtenir un tableau d'√©l√©ments al√©atoires √† partir d'un tableau donn√©
         * @param {Array} arr - Le tableau d'origine
         * @param {number} nbElement - Le nombre d'√©l√©ments √† s√©lectionner
         * @return {Array} - Un tableau contenant les √©l√©ments s√©lectionn√©s
         */
        function getRandomArr(arr, nbElement) {
            let indices = new Set();
            while (indices.size < nbElement) {
                indices.add(Math.floor(Math.random() * arr.length));
            }
            return [...indices].map(i => arr[i]);
        }

        // Fonction pour appliquer une randomisation de texture et de shader uniquement √† scene2
        async function applyRandomizationToScene2(lascene, excludedModels) {
            const randomCount = getRandomNumberBetween5And10(); // G√©n√©rer un nombre al√©atoire entre 5 et 10
            const elementsToRandomize = getRandomArr(modifiableElements, randomCount); // Obtenir des √©l√©ments al√©atoires
            const uniqueColors = [];
            
            lascene.traverse((child) => {
                if (child.isMesh && child.userData.selectable === true && !excludedModels.includes(child.name) && elementsToRandomize.includes(child.name)) {
                    let uniqueColor = generateUniqueColor(uniqueColors); // G√©n√©rer une couleur unique
                    child.material.color.set(uniqueColor); // Appliquer la couleur unique
                    uniqueColors.push(uniqueColor); // Stocker la couleur pour garantir l'unicit√©
                    addModifiedElement(child); // Ajouter l'√©l√©ment √† la liste des modifi√©s
                }
            });
        }

       // Ajouter un √©couteur pour la touche "u"
        document.addEventListener("keydown", (event) => {
            if (event.key === "u") {
                // Parcourir les √©l√©ments modifi√©s et les afficher en jaune
                modifiedElements.forEach((element) => {
                    if (element.material) {
                        element.material.color.set(0xffff00); // Couleur jaune
                    }
                });
            }
        });

        let isViolet = false; // Variable pour suivre l'√©tat de la couleur

        // Ajouter un √©couteur pour la touche "i"
        document.addEventListener("keydown", (event) => {
            if (event.key === "i") {
                scene2.traverse((child) => {
                    if (child.isMesh && child.userData.selectable === true) {
                        if (child.material) {
                            if (!isViolet) {
                                // Met en √©vidence les √©l√©ments modifiables
                                if (child.userData.originalColor === undefined) {
                                    child.userData.originalColor = child.material.color.getHex();
                                }
                                child.material.color.set(0x800080); // Couleur violet
                            } else {
                                // Repasser √† la couleur normale
                                if (child.userData.originalColor !== undefined) {
                                    child.material.color.set(child.userData.originalColor);
                                }
                            }
                        }
                    }
                });
                isViolet = !isViolet; // Inverser l'√©tat
            }
        });

        // Ajouter une fonctionnalit√© pour basculer la visibilit√© de la bo√Æte √† outils avec la touche "t"
        const toolbox = document.querySelector('.toolbox');
        toolbox.style.display = 'none'; // Masquer initialement la bo√Æte √† outils

        document.addEventListener('keydown', (event) => {
            if (event.key === 't') {
                toolbox.style.display = toolbox.style.display === 'none' ? 'block' : 'none';
            }
        });

        // Fonction pour changer la couleur des √©l√©ments mesh, en excluant `scene.gltf`
        function changeMeshColor(scene, color) {
            scene.traverse((child) => {
                if (child.isMesh && child.material && child.userData.selectable) {
                    child.material.color.set(color); // Appliquer la couleur sp√©cifi√©e
                }
            });
        }

        // Exemple d'utilisation : changer la couleur des mesh de `scene2` en rouge
        changeMeshColor(scene2, 0xff0000);

        // Configuration de la troisi√®me sc√®ne
        const scene3 = new THREE.Scene();
        scene3.background = new THREE.Color(0x80CEFF); // Appliquer le m√™me fond que les sc√®nes principales

        const camera3 = new THREE.PerspectiveCamera(30, SCREEN_WIDTH / SCREEN_HEIGHT, 0.1, 200);
        camera3.position.set(0, 2, 5); // Ajuster la position pour voir les torus
        camera3.lookAt(0, 0, 0);

        // ShaderMaterial pour les torus
        const torusShaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uResolution: { value: new THREE.Vector2(SCREEN_WIDTH, SCREEN_HEIGHT) },
                uMouse: { value: new THREE.Vector2(0, 0) },
                uTime: { value: 0 }
            },
            vertexShader: `
                varying vec3 vUv; 
                void main() {
                    vUv = position; 
                    vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                    gl_Position = projectionMatrix * modelViewPosition; 
                }
            `,
            fragmentShader: `
                uniform vec2 uResolution;
                uniform vec2 uMouse;
                uniform float uTime;
                varying vec3 vUv;
                void main() {
                    vec2 p = gl_FragCoord.xy / uResolution.xy;
                    vec3 color = vec3(
                        0.5 + 0.5 * sin(uTime + vUv.x) * 0.8 + 0.2,
                        0.5 + 0.5 * cos(uTime + vUv.y) * 0.8 + 0.2,
                        0.5 + 0.5 * sin(uTime) * 0.8 + 0.2
                    );
                    gl_FragColor = vec4(color, 1.0);
                }
            `
        });

        // Cr√©ation des trois torus
        const torusGeometry = new THREE.TorusGeometry(0.5, 0.2, 16, 100);
        const torus1 = new THREE.Mesh(torusGeometry, torusShaderMaterial);
        const torus2 = new THREE.Mesh(torusGeometry, torusShaderMaterial);
        const torus3 = new THREE.Mesh(torusGeometry, torusShaderMaterial);

        torus1.position.set(-1.5, 0, 0);
        torus2.position.set(0, 0, 0);
        torus3.position.set(1.5, 0, 0);

        scene3.add(torus1, torus2, torus3);

        // Lumi√®re pour la troisi√®me sc√®ne
        const light3 = new THREE.DirectionalLight(0xffffff, 1);
        light3.position.set(0, 5, 5);
        scene3.add(light3);

        // Gestion des vies
        let lives = 3; // Nombre initial de vies
        const torusLives = [torus1, torus2, torus3]; // Les torus repr√©sentent les vies

        function updateLivesDisplay() {
            torusLives.forEach((torus, index) => {
                torus.visible = index < lives; // Afficher uniquement les torus correspondant aux vies restantes
            });
        }

        function loseLife() {
            if (lives > 0) {
                lives--;
                updateLivesDisplay();
                if (lives === 0) {
                    showGameOverScreen(); // Afficher l'√©cran de fin si toutes les vies sont perdues
                }
            }
        }

        function showGameOverScreen() {
            endScreen.style.display = 'flex'; // Afficher l'√©cran de fin
            endScreen.querySelector('h1').innerText = 'Vous avez perdu !'; // Modifier le message
        }

        // Initialiser l'affichage des vies
        updateLivesDisplay();

        // Masquer le menu et d√©marrer le jeu
        const menuOverlay = document.getElementById('menuOverlay');
        const startButton = document.getElementById('startButton');
        const backgroundMusic = document.getElementById('backgroundMusic');
        const volumeSlider = document.getElementById('volumeSlider');
        const volumeControl = document.querySelector('.volume-control');

        // Initialiser le volume
        backgroundMusic.volume = volumeSlider.value;

        // Mettre √† jour le volume lorsque le slider change
        volumeSlider.addEventListener('input', () => {
            backgroundMusic.volume = volumeSlider.value;
        });

        startButton.addEventListener('click', async () => {
            menuOverlay.style.display = 'none';
            backgroundMusic.play();
            volumeControl.style.display = 'flex';

            applyRandomizationToScene2(scene2, excludedModels);
            updateCounter(); // Initialiser le compteur
            animate();
        });

        // Ajouter un √©couteur pour la touche "r" pour r√©initialiser la position des cam√©ras
        document.addEventListener('keydown', (event) => {
            if (event.key === 'r') {
                // R√©initialiser la position et l'orientation des cam√©ras
                camera.position.set(0, 5, 10);
                camera.lookAt(0, 0, 0);
                camera.updateProjectionMatrix();

                camera2.position.set(0, 5, 10);
                camera2.lookAt(0, 0, 0);
                camera2.updateProjectionMatrix();

                camera3.position.set(0, 5, 10);
                camera3.lookAt(0, 0, 0);
                camera3.updateProjectionMatrix();
            }
        });

        // Emp√™cher l'animation de d√©marrer avant de cliquer sur "Commencer"
        function animate() {
            requestAnimationFrame(animate);

            const elapsedTime = clock.getElapsedTime();
            torusShaderMaterial.uniforms.uTime.value = elapsedTime;

            controls.update();
            controls2.update();

            const delta = clock.getDelta();
            mixers.forEach(mixer => mixer.update(delta));

            // Mettre √† jour le Raycaster pour le survol des objets dans la sc√®ne 2
            highlightObjectsScene2();

            // Rendu de la premi√®re sc√®ne avec la premi√®re cam√©ra
            renderer.setViewport(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setScissor(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setScissorTest(true);
            camera.aspect = (SCREEN_WIDTH / 2) / SCREEN_HEIGHT; // Ajuster le ratio d'aspect de la cam√©ra 1
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);

            // Rendu de la deuxi√®me sc√®ne avec la deuxi√®me cam√©ra
            renderer.setViewport(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setScissor(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setScissorTest(true);
            camera2.aspect = (SCREEN_WIDTH / 2) / SCREEN_HEIGHT; // Ajuster le ratio d'aspect de la cam√©ra 2
            camera2.updateProjectionMatrix();
            renderer.render(scene2, camera2);

            // Rendu de la troisi√®me sc√®ne (en haut, centr√© horizontalement)
            const thirdSceneWidth = SCREEN_WIDTH / 5; // R√©duire l√©g√®rement la taille de la fen√™tre
            const thirdSceneHeight = SCREEN_HEIGHT / 5;
            const thirdSceneX = (SCREEN_WIDTH - thirdSceneWidth) / 2; // Centrer horizontalement
            const thirdSceneY = SCREEN_HEIGHT - thirdSceneHeight - 10; // Positionner en haut avec un l√©ger d√©calage
            renderer.setViewport(thirdSceneX, thirdSceneY, thirdSceneWidth, thirdSceneHeight);
            renderer.setScissor(thirdSceneX, thirdSceneY, thirdSceneWidth, thirdSceneHeight);
            renderer.setScissorTest(true);
            camera3.aspect = thirdSceneWidth / thirdSceneHeight;
            camera3.updateProjectionMatrix();
            renderer.render(scene3, camera3);
        }

        function onWindowResize() {
            SCREEN_WIDTH = window.innerWidth;
            SCREEN_HEIGHT = window.innerHeight;

            // Mettre √† jour les ratios d'aspect pour les deux cam√©ras
            camera.aspect = (SCREEN_WIDTH / 2) / SCREEN_HEIGHT;
            camera.updateProjectionMatrix();

            camera2.aspect = (SCREEN_WIDTH / 2) / SCREEN_HEIGHT;
            camera2.updateProjectionMatrix();

            camera3.aspect = (SCREEN_WIDTH / 5) / (SCREEN_HEIGHT / 5);
            camera3.updateProjectionMatrix();

            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        }
        window.addEventListener("resize", onWindowResize);

        function evenementTouche(event) {
            switch (event.key) {
                // Ajouter des actions pour les touches ici
            }
        }
        document.addEventListener("keydown", evenementTouche);

        // Ajouter un √©couteur pour d√©tecter les mouvements de la souris
        window.addEventListener('mousemove', onMouseMove);
    </script>
</body>
</html>

<!-- boucle de rendu : cube qui tourne
    exo 3 : lumi√®re directionnelle
    exo 4 : redimensionnement
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé≠ Double Vision</title>
    <style>
        body {
            margin: 0;
        }
        .center-divider {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0.3vw;
            height: 100%;
            background-color: black;
        }
    </style>
</head>
<body>
    <div class="center-divider"></div>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.121.1/build/three.module.js';
        import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/controls/OrbitControls.js';
        import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.121.1/examples/jsm/loaders/GLTFLoader.js';        
        const scene = new THREE.Scene();
        let SCREEN_WIDTH = window.innerWidth;
        let SCREEN_HEIGHT = window.innerHeight;
        scene.background = new THREE.Color(0x80CEFF); // Couleur du ciel
        const ratioLargeurHauteur = SCREEN_WIDTH / SCREEN_HEIGHT;

        const camera = new THREE.PerspectiveCamera(30, ratioLargeurHauteur, 0.1, 200); // Distance d'affichage
        camera.position.set(0, 5, 10); // Ajuster la position pour voir la sc√®ne
        camera.lookAt(0, 0, 0); // Orientation de la cam√©ra

        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.minDistance = 2;
        controls.maxDistance = 5;
        controls.maxPolarAngle = Math.PI / 2;
        controls.dampingFactor = 0.05;

        const clock = new THREE.Clock();
        const mixers = [];

        const loaderGLTF = new GLTFLoader();

        const sunLight = new THREE.DirectionalLight(0xffdd88, 1.5); // Lumi√®re chaude pour simuler le soleil
        sunLight.position.set(10, 20, 10); // Position √©lev√©e pour simuler le soleil
        sunLight.castShadow = true; // Active les ombres
        sunLight.shadow.mapSize.width = 1024; // Taille de la carte d'ombre
        sunLight.shadow.mapSize.height = 1024;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 50;
        scene.add(sunLight);

        // Abaisser la premi√®re sc√®ne
        scene.position.y -= 0.5;

        // Configuration de la deuxi√®me sc√®ne
        const scene2 = new THREE.Scene();
        scene2.background = new THREE.Color(0x80CEFF); // M√™me couleur de fond que la premi√®re sc√®ne

        const camera2 = new THREE.PerspectiveCamera(30, SCREEN_WIDTH / SCREEN_HEIGHT, 0.1, 200);
        camera2.position.set(0, 5, 10); // Ajuster la position pour voir la sc√®ne
        camera2.lookAt(0, 0, 0);

        const controls2 = new OrbitControls(camera2, renderer.domElement);
        controls2.minDistance = 2;
        controls2.maxDistance = 5;
        controls2.maxPolarAngle = Math.PI / 2;
        controls2.dampingFactor = 0.05;

        // Cloner la lumi√®re pour la deuxi√®me sc√®ne
        const sunLight2 = sunLight.clone();
        scene2.add(sunLight2);

        // Abaisser la deuxi√®me sc√®ne
        scene2.position.y -= 0.5;

        const models = []; // Tableau pour stocker les mod√®les de la premi√®re sc√®ne
        const models2 = []; // Tableau pour stocker les mod√®les de la deuxi√®me sc√®ne
        const separatedObjects = []; // Tableau pour stocker les objets s√©par√©s

        function loadModel(path, scene, models, separatedObjects, selectable = false) {
            loaderGLTF.load(
                path,
                function (gltf) {
                    const mesh = gltf.scene;
                    const s = 0.35;
                    mesh.scale.set(s, s, s);
                    mesh.position.set(0, 0, 0); // Centrer le mod√®le dans la sc√®ne
                    mesh.rotation.x = 0; // Mettre √† la verticale

                    // Ajouter le mod√®le √† la sc√®ne
                    scene.add(mesh);
                    models.push(mesh); // Stocker le mod√®le dans le tableau

                    // Parcourir les enfants du mod√®le et attribuer le statut s√©lectionnable
                    mesh.traverse((child) => {
                        if (child.isMesh) {
                            child.userData.selectable = selectable; // Attribuer le statut s√©lectionnable
                            if (selectable) {
                                separatedObjects.push(child); // Ajouter uniquement les objets s√©lectionnables
                                console.log(`Objet s√©lectionnable ajout√© (${path}):`, child.name);
                            } else {
                                console.log(`Objet non s√©lectionnable charg√© (${path}):`, child.name);
                            }
                        }
                    });
                },
                undefined,
                function (err) {
                    console.error(`Erreur de chargement du mod√®le (${path}):`, err);
                }
            );
        }

        // Charger les mod√®les dans les deux sc√®nes
        loadModel('../Models/isometric_bedroom/scene.gltf', scene, models, separatedObjects, false); // Non s√©lectionnable
        loadModel('../Models/isometric_bedroom/scene.gltf', scene2, models2, separatedObjects, false); // Non s√©lectionnable
        loadModel('../Models/isometric_bedroom/textures/models/bag.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/bag.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/cup.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/cup.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/mouse.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/mouse.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/console.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/console.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/book1.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/book1.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/slipers.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/slipers.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/frames.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/frames.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/lamp.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/lamp.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/book2.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/book2.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/book3.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/book3.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/chair.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/chair.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/book4.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/book4.gltf', scene2, models2, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/table.gltf', scene, models, separatedObjects, true);
        loadModel('../Models/isometric_bedroom/textures/models/table.gltf', scene2, models2, separatedObjects, true);

        const raycaster = new THREE.Raycaster(); // Raycaster pour d√©tecter les objets
        const mouse = new THREE.Vector2(); // Position de la souris
        let previousIntersected = null; // Dernier objet intersect√©

        function onMouseMove(event) {
            // Calculer la position de la souris en coordonn√©es normalis√©es (-1 √† +1)
            mouse.x = ((event.clientX - SCREEN_WIDTH / 2) / (SCREEN_WIDTH / 2)) * 2 - 1; // Ajuster pour la sc√®ne 2
            mouse.y = -(event.clientY / SCREEN_HEIGHT) * 2 + 1;
        }

        function highlightObjectsScene2() {
            // Effectuer un raycast √† partir de la position de la souris
            raycaster.setFromCamera(mouse, camera2);

            // V√©rifier les intersections avec les objets de la sc√®ne 2
            const intersects = raycaster.intersectObjects(models2, true).filter(intersect => intersect.object.isMesh && intersect.object.userData.selectable);

            if (previousIntersected && previousIntersected !== intersects[0]?.object) {
                // R√©initialiser la couleur de la derni√®re Mesh s√©lectionn√©e
                if (previousIntersected.material && previousIntersected.userData.originalColor) {
                    previousIntersected.material.color.set(previousIntersected.userData.originalColor);
                }
                previousIntersected = null;
            }

            if (intersects.length > 0) {
                const intersected = intersects[0].object;

                // V√©rifier que l'objet intersect√© est une Mesh et qu'il a un mat√©riau
                if (intersected.isMesh && intersected.material) {
                    // Sauvegarder la couleur d'origine et appliquer une couleur bleue
                    if (!intersected.userData.originalColor) {
                        intersected.userData.originalColor = intersected.material.color.getHex();
                    }
                    intersected.material.color.set(0x0000ff); // Appliquer une couleur bleue
                    previousIntersected = intersected;
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            controls.update();
            controls2.update();

            const delta = clock.getDelta();
            mixers.forEach(mixer => mixer.update(delta));

            // Mettre √† jour le Raycaster pour le survol des objets dans la sc√®ne 2
            highlightObjectsScene2();

            // Rendu de la premi√®re sc√®ne avec la premi√®re cam√©ra
            renderer.setViewport(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setScissor(0, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setScissorTest(true);
            camera.aspect = (SCREEN_WIDTH / 2) / SCREEN_HEIGHT; // Ajuster le ratio d'aspect de la cam√©ra 1
            camera.updateProjectionMatrix();
            renderer.render(scene, camera);

            // Rendu de la deuxi√®me sc√®ne avec la deuxi√®me cam√©ra
            renderer.setViewport(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setScissor(SCREEN_WIDTH / 2, 0, SCREEN_WIDTH / 2, SCREEN_HEIGHT);
            renderer.setScissorTest(true);
            camera2.aspect = (SCREEN_WIDTH / 2) / SCREEN_HEIGHT; // Ajuster le ratio d'aspect de la cam√©ra 2
            camera2.updateProjectionMatrix();
            renderer.render(scene2, camera2);
        }
        animate();

        function onWindowResize() {
            SCREEN_WIDTH = window.innerWidth;
            SCREEN_HEIGHT = window.innerHeight;

            // Mettre √† jour les ratios d'aspect pour les deux cam√©ras
            camera.aspect = (SCREEN_WIDTH / 2) / SCREEN_HEIGHT;
            camera.updateProjectionMatrix();

            camera2.aspect = (SCREEN_WIDTH / 2) / SCREEN_HEIGHT;
            camera2.updateProjectionMatrix();

            renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);
        }
        window.addEventListener("resize", onWindowResize);

        function evenementTouche(event) {
            switch (event.key) {
                // Ajouter des actions pour les touches ici
            }
        }
        document.addEventListener("keydown", evenementTouche);

        // Ajouter un √©couteur pour d√©tecter les mouvements de la souris
        window.addEventListener('mousemove', onMouseMove);
    </script>
</body>
</html>